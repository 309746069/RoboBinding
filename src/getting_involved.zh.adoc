参与开发
========
:Revision: 0.8.2
:toc:
:numbered:
:imagesdir: ./images

搭建Eclipse开发环境
-------------------
安装工具
~~~~~~~~
* http://www.eclipse.org/[Eclipse] IDE for Java Developers或其超集
* 安装http://developer.android.com/tools/sdk/eclipse-adt.html[Android Development Tools(ADT)] plugin
* 安装http://www.eclipse.org/ajdt/[AspectJ Development Tools(AJDT)] plugin(由于项目的部分代码用AspcectJ编写)
* 安装the m2e build-helper connector。打开Eclipse->Window->Preferences->Maven->Discovery->open catalog，安装buildhelper


导入项目
~~~~~~~~
下载项目，可以通过Eclipse Git客户端，或其它的Git客户端如TortoiseGit，git命令行等。项目地址为https://github.com/RoboBinding/RoboBinding。

下载完毕后按昭以下步骤将项目导入Eclipse。
Window->Open Perspective->Other->Git Repository Exploring。点击Add an existing local Git repository(如果之前不是用eclipse git客户端下载项目的)，将本地的Git repositories加进来。
展开RoboBinding repository，右击Working Directory->Import existing projects，选择[path to local git repository]\RoboBinding\robobinding，将项目导入Eclipse工作区。

导入之后项目的pom.xml会出现以下两个错误，右击他们Quick Fix->忽略他们就好了。

* Plugin execution not covered by lifecycle configuration: org.codehaus.mojo:aspectj-maven-plugin:1.4:compile (execution: aspectj-compile, phase: compile)
* Plugin execution not covered by lifecycle configuration: org.codehaus.mojo:build-helper-maven-plugin:1.4:add-test-source (execution: add-generated-R-file-to-sources, phase: generate-sources)

接下来右击src/test/java源代码目录->Run As->JUnit Test->Eclipse JUnit Launcher，运行所有的单元测试。如果所有的单元测试都是通过的，环境搭建完成。

RoboBinding架构与实现
---------------------

RoboBinding是一个实现Martin Fowler的http://martinfowler.com/eaaDev/PresentationModel.html[Presentation Model]构架模式的Android框架。
目标为减少Android应用开发工作量；促进清晰的项目结构；使项目代码更易于测试。基于RoboBinding的Android应用的结构如下图。

从Android应用结构上看
~~~~~~~~~~~~~~~~~~~~~

.基于RoboBinding的Android应用
image::robobinding_based_app.png[]

一个Android应用包含了若干个Activity以及其它的元素。在基于RoboBinding的应用里一个Activity包含了Activity主文件，Layout文件以及PresentationModel文件
(而Android普通应用一个Activity只包含了Activity主文件与Layout文件)。原先位于Activity内的显示层逻辑被提取到独立的文件PresentationModel内。
Activity利用RoboBinding将Layout与对应的显示逻辑PresentationModel绑定在一起。把Layout中的显示数据与PresentationModel中的属性绑定；
Layout中的事件与PresentationModel中的方法绑定。RoboBinding替代了原先在Activity中的UI关联代码，减少应用代码。
在理想的情况下，PresentationModel只包含显示逻辑不包含UI代码，便与独立测试。

从RoboBinding实现概览上看
~~~~~~~~~~~~~~~~~~~~~~~~

.RoboBinding实现概要图
image::architecture.png[]

以上为RoboBinding框架实现的概要。黄色背景的两张图(Client与PresentationModel)为应用代码，其它的三个为框架代码。图中只列举了来自一些包的核心类。
Client(Activity，Dialog或Custom View)将Layout传递给对应的Binder(ActivityBinder, DialogBinder或ViewBinder)，
Binder从给定的Layout文件构建起View层次结构(利用Android的内部android.view.LayoutInflater功能)以及RoboBinding绑定信息。
一个根View可能包含若干个子View，子View可能包含下级View，形成一个树状的结构。每一个View中可能包含若干个视图绑定属性。
RoboBinding中定义了三类视图绑定属性，分别是PropertyViewAttribute(org.robobinding.viewattribute.PropertyViewAttribute)，CommandViewAttribute(org.robobinding.viewattribute.AbstractCommandViewAttribute)，以及GroupedViewAttribute(org.robobinding.viewattribute.AbstractGroupedViewAttribute)。
PropertyViewAttribute实现Layout中的显示数据与PresentationModel中的属性绑定；CommandViewAttribute实现Layout中的事件与PresentationModel中的方法绑定；
而GroupedViewAttribute由若干个PropertyViewAttribute与CommandViewAttribute组成，用于实现一个复合视图属性由多个子属性构成的情况。
PropertyViewAttribute通过org.robobinding.presentationmodel.PresentationModelAdapter的org.robobinding.property.PropertyValueModel(如果是简单属性)或org.robobinding.property.DataSetValueModel(如果是复杂的数据集合属性)
映射到PresentationModel的属性或DataSet型属性。CommandViewAttribute通过PresentationModelAdapter的org.robobinding.function.Function映射到PresentationModel的方法。

.RoboBinding实现例子概要图
image::architecture_sample.png[]
上图以实例解释了框架的实现概要。黄色背景的三张图摘自RoboBinding-Sample项目的源代码，其它二个为应用运行时框架产生的对应的核心代码实例。
ViewAlbumsActivity通过框架(这里为org.robobinding.binder.Binders类)将layout与presentationModel绑定在一起。
图中的第一个为简单视图属性的绑定例子。框架为++\{windowsTitle\}++产生一个org.robobinding.viewattribute.textview.TextAttribute实例，而TextAttribute实例通过PresentationModelAdapter的PropertyValueModel
将++\{windowTitle\}++与ViewAlbumsPresentationModel.windowTitle绑定在一起。第二个为复合视图属性的绑定例子。ListView的source与itemLayout为复合视图属性，框架为++\{albums\}++与++@layout/album_row++
产生一个org.robobinding.viewattribute.adapterview.AdaptedDataSetAttributes复合视图属性实例，此复合视图属性包含两个子视图属性
org.robobinding.viewattribute.adapterview.SourceAttribute与org.robobinding.viewattribute.adapterview.StaticLayoutAttribute分别和++\{albums\}++及其++@layout/album_row++相对应。
而SourceAttribute实例通过PresentationModelAdapter的DataSetValueModel将++\{albums\}++与ViewAlbumsPresentationModel.albums绑定在一起；
而StaticLayoutAttribute通过解析++@layout/album_row++关联到外部文件album_row.xml。第三个为视图事件属性的绑定例子。
框架为++createAlbum++产生一个org.robobinding.viewattribute.view.OnClickAttribute实例，而OnClickAttribute实例通过PresentationModelAdapter的Function
将++createAlbum++与ViewAlbumsPresentationModel.createAlbum绑定在一起。

从RoboBinding实现细节上看
~~~~~~~~~~~~~~~~~~~~~~~~

org.robobinding与org.robobinding.binder包
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
image::developer_usecase_sequence.png[]
如上图所示，应用开发者通过两个可能的入口点使用框架(以两种不同的颜色区分)。第一种是通过org.robobinding.binder.Binders工具类来使用框架，由于是工具类，随时随地可用，无需创建实例，方便；
Binders内部其实每次是通过org.robobinding.binder.BinderFactoryBuilder以默认配置的创建新的org.robobinding.binder.BinderFactory实例，然后调用BinderFactory间接的完成整个绑定；
其缺点是每次都产生新的BinderFactory实例且BinderFactoryBinder只能是默认的配置。第二种是通过BinderFactoryBuilder配置创建BinderFactory实例，
通过配置应用开发者可以增加新的视图，视图可绑定属性映射类(org.robobinding.viewattribute.BindingAttributeMapper子类)及其可选的视图事件监听器聚集(org.robobinding.viewattribute.view.ViewListeners子类)；
或者提供定制的视图可绑定属性映射类来覆盖框架的默认实现。
通过第二种方式时，BinderFactory实例可以被重用，应用开发者可将实例保存在应用类里(即实现了android.app.Application的子类)或者通过第三方的框架如
https://github.com/roboguice/roboguice[RoboGuice]注入BinderFactory实例。不管是选择前面两种方式的哪一种，其实真正功能的入口类都是BinderFactory。
根据应用程序的要求，调用org.robobinding.ActivityBinder，org.robobinding.DialogBinder或org.robobinding.InternalViewBinder，
而这三个类内部又通过调用org.robobinding.BinderImplementor的子类org.robobinding.binder.InternalBinder来实现layout的inflation以及绑定。
前面提到过视图事件监听器聚集(即org.robobinding.viewattribute.view.ViewListeners或其子类)，这是由于android框架的事件设计而提供的一个workaround。
因为android框架中很多事件只能注册一个事件监听器如android.view.View.setOnFocusChangeListener，但应用中有时可能需要注册多个，
为了使之前注册过的旧的事件监听器不被新的意外覆盖而提供了事件监听器聚集ViewListeners。

image::inflateview_sequence.png[]
上图展示了框架对一个layout进行inflation的整个流程及其主要的参与类。接上述说到InternalBinder类，InternalBinder将layout inflation工作交给org.robobinding.binder.BindingViewInflater；
而layout inflation工作又被转交给org.robobinding.NonBindingViewInflater。NonBindingViewInflater只做layout inflation工作，不做解析视图绑定属性的工作，
它从layout文件创建视图集。当一个视图被创建时org.robobinding.ViewFactory回调BindingViewInflater。
BindingViewInflater通过org.robobinding.binder.BindingAttributeParser解析出该视图的待绑定视图属性映射org.robobinding.PendingAttributesForView。
就这样重复以上的过程，直到解析出layout中所有视图的待绑定视图属性映射PendingAttributesForView为止。
然后待绑定视图属性映射PendingAttributesForView被放入org.robobinding.binder.BindingAttributeResolver进行解析转化构建视图的绑定属性集。
BindingAttributeResolver通过org.robobinding.binder.ByBindingAttributeMappingResolverFinder从上至下为视图寻找匹配的绑定属性解析转化器org.robobinding.binder.ByBindingAttributeMappingResolver集
(例如android.widget.EditText继承于android.widget.TextView，而TextView继承于android.view.View。一个EditText实例视图将匹配得到三个绑定属性解析转化器：EditText绑定属性解析转化器，TextView绑定属性解析转化器以及View绑定属性解析转化器。)。
BindingAttributeResolver通过调用所有匹配到的绑定属性解析转化器ByBindingAttributeMappingResolver得到最后的视图绑定属性集org.robobinding.binder.ResolvedBindingAttributesForView返回给BindingViewInflater。
BindingViewInflater接着添加所有预定义的待绑定视图属性映射org.robobinding.PredefinedPendingAttributesForView，如果有的话。然后调用BindingAttributeResolver解析转化构建视图的绑定属性集，
过程与之前解析转化待绑定视图属性映射PendingAttributesForView一样，最后也得到视图绑定属性集ResolvedBindingAttributesForView。
BindingViewInflater将包含所有视图绑定属性集ResolvedBindingAttributesForView的org.robobinding.binder.InflatedView返回InternalBinder。整个layout的inflation工作结束。接着是下一步的绑定。

image::bindview_sequence.png[]
上图展示了整个绑定的过程以及主要的参与类。InternalBinder通过调用上一步返回的InflatedView来绑定所有的视图绑定属性集ResolvedBindingAttributesForView。
而视图绑定属性集ResolvedBindingAttributesForView内部又调用各个视图绑定属性org.robobinding.viewattribute.ViewAttribute完成绑定。
绑定完成之后，InternalBinder校验所有绑定是否都成功，不成功就终止并报告错误。如果成功，就接着预初始化视图值(如果需要的话)。
预初始化视图值即将PresentationModel的初值设置到视图上。

org.robobinding.viewattribute与org.robobinding.viewattribute$$.*$$包
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.ViewAttribute类层次关系图
image::viewattribute_hierarchy.png[]
视图属性主要包含三类：简单视图属性org.robobinding.viewattribute.PropertyViewAttribute，命令视图属性org.robobinding.viewattribute.AbstractCommandViewAttribute，
以及复合视图属性org.robobinding.viewattribute.AbstractGroupedViewAttribute。PropertyViewAttribute为简单视图属性绑定提供实现，
分为两种，即单值简单视图属性org.robobinding.viewattribute.AbstractPropertyViewAttribute与多值简单视图属性org.robobinding.viewattribute.AbstractMultiTypePropertyViewAttribute。
单值简单视图属性AbstractPropertyViewAttribute(如图[1.1]标注的++\{enabledSwitch\}++，++\{selectedSwitch\}++)
即只有一种可能类型的值如org.robobinding.viewattribute.view.EnabledAttribute，只有Boolean类型的值。
多值简单视图属性AbstractMultiTypePropertyViewAttribute(如图[1.2]标注的++\{visibilitySwitch\}++)
即有多种可能类型的值如org.robobinding.viewattribute.view.AbstractVisibilityAttribute控制是否可视，可能有Boolean或Integer类型的值。
AbstractCommandViewAttribute(如图[2]标注的++onClick++，++onLongClick++)为命令视图属性绑定提供实现，
如org.robobinding.viewattribute.view.OnClickAttribute，org.robobinding.viewattribute.view.OnLongClickAttribute等。
AbstractGroupedViewAttribute(如图[3.1，3.2]标注的++\{source\}++，++@layout/item_row++，++\{[text1.text:\{name\}]\}++；++@layout/footer_layout++，++\{footer\}++，++\{footerVisibility\}++)
为复合视图属性绑定提供实现，如org.robobinding.viewattribute.adapterview.AdaptedDataSetAttributes由子属性source，itemLayout以及可选的itemMapping构成；
org.robobinding.viewattribute.listview.FooterAttributes由子属性footerLayout以及可选的footerPresentationModel与footerVisibility构成。
org.robobinding.viewattribute包 包含了主要的概念抽象类，而org.robobinding.viewattribute子包对应android.widget包下的各种widget的视图属性绑定实现。
如org.robobinding.viewattribute.textview包对应android.widget.TextView；org.robobinding.viewattribute.seekbar包对应android.widget.SeekBar。


ViewAttribute生命周期方法：initialize->bindTo->preInitializeView。
三种视图属性(即简单视图属性PropertyViewAttribute，命令视图属性AbstractCommandViewAttribute以及复合视图属性AbstractGroupedViewAttribute)都存在着一致的生命周期方法。
即初始化(initialize)，绑定(bindTo)以及可选的预初始化视图(preInitializeView)。三个方法由前至后的顺序被调用。预初始化视图方法只有在被要求的情况下才会被调用。


.ChildViewAttributes类关系图
image::childviewattribute_relationship.png[]
上图展示了AbstractGroupedViewAttribute复合视图属性与子属性的关系。AbstractGroupedViewAttribute包含了各种类型的子属性，目前主要有四类，即org.robobinding.viewattribute.ChildViewAttribute，
org.robobinding.viewattribute.DependentChildViewAttribute，org.robobinding.viewattribute.PropertyViewAttribute，org.robobinding.viewattribute.DependentPropertyViewAttribute。
ChildViewAttribute为普通的子视图属性，其下又包含了org.robobinding.viewattribute.ChildViewAttributeWithAttribute；ChildViewAttributeWithAttribute为带属性值的子视图属性，在该子属性被创建时，
框架将赋予所需的属性值，例如：org.robobinding.viewattribute.adapterview.SourceAttribute，org.robobinding.viewattribute.adapterview.SubViewLayoutAttribute。
DependentChildViewAttribute为依赖型子视图属性，该类型的子视图属性不能被简单的被创建，因为它们依赖于外部的一些信息，
而由一个org.robobinding.viewattribute.ChildViewAttributeFactory工厂创建；例如org.robobinding.viewattribute.adapterview.SubViewAttributes.SubViewAttributeFactory，
提供一个org.robobinding.viewattribute.adapterview.SubViewPresentationModelAttribute还是org.robobinding.viewattribute.adapterview.SubViewWithoutPresentationModelAttribute，
需要一个运行时信息++hasSubViewPresentationModel++来决定。PropertyViewAttribute为简单视图属性或其子类，前面已经提到过，可以重用系统中已有的简单视图属性作为复合视图属性的子属性。
DependentPropertyViewAttribute与DependentChildViewAttribute类似，为依赖型简单视图属性；依赖于外部的一些信息，由一个org.robobinding.viewattribute.ViewAttributeFactory工厂创建；
例如org.robobinding.viewattribute.adapterview.SubViewAttributes.SubViewVisibilityAttributeFactory，依赖于++view++与++subView++两个外部值。

org.robobinding.presentationmodel，org.robobinding.property，org.robobinding.itempresentationmodel以及org.robobinding.function包
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.PresentationModel类关系图
image::presentationmodel_classdiagram.png[]
org.robobinding.presentationmodel，org.robobinding.property，org.robobinding.itempresentationmodel以及org.robobinding.function
这四个包的相关的类主要用于包装应用程序的PresentationModel。org.robobinding.presentationmodel.PresentationModelAdapter为这几个包的入口类。
框架为每一个应用程序PresentationModel生成一个对应的PresentationModelAdapter实例。目前框架通过两种方式识别应用程序PresentationModel，
即所有org.robobinding.presentationmodel.ObservableProperties/AbstractPresentationModel的子类或有
org.robobinding.presentationmodel.PresentationModel annotation标识的类。PresentationModelAdapter主要包装应用程序PresentationModel的三类信息，
即将SimpleProperty，DataSetProperty和Method包装为org.robobinding.property.PropertyValueModel，org.robobinding.property.DataSetValueModel
和org.robobinding.function.Function。上图右边的例子中：++windowTitle++为SimpleProperty,++albums++为DataSetProperty，++createAlbum()++为Method。
DataSetProperty是一个数据集属性，其中每一个数据项又会生成一个org.robobinding.itempresentationmodel.ItemPresentationModel实例，
上图中即为AlbumItemPresentationModel，其与对应的++@layout/album_row++配合显示相应的行。框架通过AspectJ为一些类自动的注入一些代码，以减少工作量。
例如为PresentationModel注入PresentationModelAspect，主要为Setter方法尾部追加属性值变更事件通知代码；
为ItemPresentationModel注入ItemPresentationModelAspect，即为ItemPresentationModel.updateData方法的尾部加上数据项变更刷新ItemPresentationModel来同步视图显示代码。


成为项目开发成员
----------------
项目为免费的开源项目，纯粹出于我们的个人兴趣发起的，是没有任何报酬的，我们都是利用我们的个人空闲时间来开发与维护项目。
项目的价值与宗旨是：通过参与项目，我们从中得到快乐(享受程序开发艺术以及顺畅的成员协作关系)，相互学习知识以及开发经验。
如果该项目有幸被Android开发者们认可，为Android社区做出贡献，我们将从中得到及大的满足。

参与项目技能要求
~~~~~~~~~~~~~~~~
* 具有丰富的测试驱动开发经验。
* 具有丰富的面向对象编程经验。

参与项目规则要求
~~~~~~~~~~~~~~~~
* 协作胜于个人主义。例如：当组员在开发一个任务时遇到困难，如果另一个组员有相应的知识时，应该帮助有困难的组员，但前提为不是替他完成这个任务；
我们应该尽快的处理其他组员的email，合并请求等，尽可能的不耽搁其他组员的任务开发。
* 参与以及知识分享的最大化。我们提倡组员分享和参与项目的所有部分。至少做到每一个部分都有两个以上的人参与。