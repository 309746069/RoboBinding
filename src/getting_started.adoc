Getting Started
===============
:Revision: 0.8.3
:toc:
:numbered:
:imagesdir: ./images
:source-highlighter: pygments

What is RoboBinding?
--------------------
*Bind the gap* - RoboBinding is a data-binding presentation model framework for the Android platform. RoboBinding helps you write UI code that is easier to read, test and maintain.

Property binding
~~~~~~~~~~~~~~~~

Declare a binding attribute in your layout xml:
[source,xml]
----
<EditText android:layout_width="fill_parent"
	  android:layout_height="wrap_content"
	  bind:text="${superHeroName}" />
----
provide a pojo presentation model class that exposes the relevant property:
[source,java]
----
public void setSuperHeroName(String superHeroName) {
	this.superHeroName = superHeroName;
}

public String getSuperHeroName() {
	return superHeroName;
}
----
and RoboBinding will provide fine-grained synchronization between view and presentation model.

Event handling
~~~~~~~~~~~~~~

Declare a binding attribute in your layout xml:
[source,xml]
----
<ListView android:layout_width="fill_parent"
	  android:layout_height="fill_parent"
	  bind:onItemClick="superHeroSelected" />
----
provide a pojo presentation model class that exposes an appropriate event handler:

[source,java]
----
public void superHeroSelected(ItemClickEvent event) {
	SuperHero chosenSuperHero = this.superHeroes.get(event.getPosition());
	chosenSuperHero.summon();
}
----
and RoboBinding will delegate item click events to this method.

Hello RoboBinding
-----------------
Let's watch http://skillsmatter.com/podcast/os-mobile-server/core-dev-talk-robobinding[a introductory video] by Robert Taylor to get started.

Environment Setup
~~~~~~~~~~~~~~~~~

Eclipse
^^^^^^^
Needless to say, you will need both http://eclipse.org/[Eclipse] and the http://developer.android.com/tools/sdk/eclipse-adt.html[Android Development Tools] plugin installed.

Start by adding either the 'robobinding-[xxx].jar' or the 'robobinding-[xxx]-jar-with-dependencies.jar' to the libs folder of your project, then add it to your classpath by right-clicking on your project→Properties→Java Build Path→Libraries→Add JARs. 
If you're using the jar without dependencies, you will additionally need add https://code.google.com/p/guava-libraries/[guava] 11.0.1+ jars to your classpath.

The RoboBinding framework incorporates AspectJ aspects to auto-generate the property-change notification code in your presentation models. If you want to take advantage of this (recommended), you'll need to install the http://www.eclipse.org/ajdt/[AspectJ Development Tools (AJDT)] plugin.

Once you have it installed, right-click on your project→Configure→Convert to AspectJ Project. This will add the AspectJ natures to your .project file.

Next, make sure the AspectJ Runtime Library is included in the build by right-clicking on your project→Properties→Java Build Path→Order and Export, and ensure 'AspectJ Runtime Library' is checked.

Finally, you'll need to make sure the RoboBinding jar is added to your project Aspect Path. Right click on your project→Properties→AspectJ Build→Aspect Path→Add JARs.

.Eclipse project build settings
image::eclipse_project_build_settings.png["Eclipse project build settings"]

Please feel free to take a look at https://github.com/RoboBinding/RoboBinding/[RoboBinding album sample] as reference.

Android Studio
^^^^^^^^^^^^^^
Please refer to the build file https://github.com/weicheng113/album-sample_AndroidStudio/[here] for now.

ProGuard
^^^^^^^^
RoboBinding requires that all classes which implement org.robobinding.property.ObservableProperties (i.e. presentation models) have their names and public methods left intact. Additionally, we need to preserve all annotations.

To achieve this, add the following directives to your ProGuard configuration:
[source,erlang]
----
-keep class * implements org.robobinding.property.ObservableProperties {
	public *** *(...);
}

-keepattributes *Annotation*,Signature
----

From 0.8.1 onwards, we have added a dependency on the guava libraries. At the moment ProGuard doesn't seem to play nicely with guava, so you'll need to the add the following additional lines:
[source,erlang]
----
-dontwarn com.google.common.collect.MinMaxPriorityQueue
-dontwarn sun.misc.Unsafe
----

And add the following lines also to keep the constructors of view listeners.
[source,erlang]
----
-keepclassmembers class * extends org.robobinding.viewattribute.view.ViewListeners {
	public <init>(...);
}
----
An example of proguard.cfg settings can be found underneath https://github.com/RoboBinding/RoboBinding/[RoboBinding album sample].

Maven
^^^^^
Updating. Please refer to link:old_maven.html[the old doc].

Configuring your Activity
~~~~~~~~~~~~~~~~~~~~~~~~~

In most cases, the wiring required to bind a set of views onto a presentation model will take place inside the appropriate Activity. 
You will normally want one presentation model per Activity.

In the onCreate() method of your Activity, use the ++org.robobinding.binder.Binders++ utility class or ++org.robobinding.binder.BinderFactory++(reuse the instance by keeping it in the http://developer.android.com/reference/android/app/Application.html[android.app.Application] 
or a dependency injection library like https://github.com/roboguice/roboguice[RoboGuice]) created by org.robobinding.binder.BinderFactoryBuilder to bind the content view onto a presentation model instance. 
For example:
[source,java]
----
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    SuperHeroPresentationModel presentationModel = new SuperHeroPresentationModel();
    Binders.bind(this, R.layout.super_hero_activity, presentationModel);
}
----
Notice you don't actually need to call setContentView() inside your onCreate() method, RoboBinding will do this for you.

Declaring the RoboBinding namespace
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Before declaring any bindings in your layout xml, you will need to add the RoboBinding namespace declaration to the root view of each layout. For example, inside our super_hero_activity.xml we might start:
[source,xml]
----
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:bind="http://robobinding.org/android"
    android:layout_width="fill_parent"
    android:layout_height="wrap_content" >
    
    ...
    
</RelativeLayout>
----
Property binding
~~~~~~~~~~~~~~~~

When you bind to a property on the presentation model, any changes made to that property are automatically propagated to the view.

RoboBinding adheres to the JavaBeans specification whereby to expose a property called 'superHeroName', you provide the corresponding public getters and setters:
[source,java]
----
private String superHeroName;

public String getSuperHeroName() {
    return superHeroName;
}

public void setSuperHeroName(String superHeroName) {
    this.superHeroName = superHeroName;
}
----
You can then bind to this property from a view, by using the text attribute available on the TextView class.
[source,xml]
----
<TextView android:layout_width="fill_parent"
	  android:layout_height="wrap_content"
	  bind:text="{superHeroName}" />
----
Since this is a one-way binding, it would have been acceptable to provide a read-only property in our presentation model, if we so wished:
[source,java]
----
public String getSuperHeroName() {
    return "Powdered Toast Man!";
}
----
See https://oss.sonatype.org/service/local/repositories/releases/archive/org/robobinding/robobinding/0.8.2/robobinding-0.8.2-javadoc.jar/!/index.html[API and Binding Attributes JavaDocs] for more on the available binding attributes.

Two-way property binding
~~~~~~~~~~~~~~~~~~~~~~~~

Two-way binding takes property binding one step further, and ensures that as well as propagating changes from the presentation model to the view, any changes to the view are also synched back to the presentation model.

EditText fields are one of the UI elements that support two-way binding. In this case, whenever a text change is made by the user, the presentation model is updated accordingly.

To use two-way binding, we simply prepend a dollar ($) sign before the curly braces we used in our one-way binding declaration, like so:
[source,java]
----
<EditText android:layout_width="fill_parent"
	  android:layout_height="wrap_content"
	  bind:text="${superHeroName}" />
----
That's the only thing we have to do. Note that in the case of two-way binding, we would need to have given RoboBinding write-access to the property, so supplying a setter method on our presentation model is compulsory.

Event handling
~~~~~~~~~~~~~~

In order to further keep logic decoupled from your views, RoboBinding also gives you the ability to delegate input events to your presentation model. 
Different views support different input events (See https://oss.sonatype.org/service/local/repositories/releases/archive/org/robobinding/robobinding/0.8.2/robobinding-0.8.2-javadoc.jar/!/index.html[API and Binding Attributes JavaDocs] for a comprehensive list).

Declaring event handlers is very similar to declaring property bindings, you just omit the curly braces. ListView supports an onItemClick binding attribute (inherited from AdapterView); we can delegate this event to the presentation model like so:
[source,java]
----
<ListView android:layout_width="fill_parent"
	  android:layout_height="fill_parent"
	  bind:onItemClick="superHeroSelected" />
----
RoboBinding will delegate this event to a method called superHeroSelected on your presentation model. If your method requires an argument that corresponds to the event class associated with this event, RoboBinding will parcel one up and pass it to you when invoking your method. For example:
[source,java]
----
private List<SuperHero> superHeroes;

public void superHeroSelected(ItemClickEvent event) {
	SuperHero chosenSuperHero = this.superHeroes.get(event.getPosition());
	chosenSuperHero.summon();
}
----
If we only wanted to know that an item had been clicked, but not which specific item was clicked, the following would also have worked:
[source,java]
----
public void superHeroSelected() {
	System.out.println("SuperHeroes being summoned!");
}
----
Binding with AdapterViews
~~~~~~~~~~~~~~~~~~~~~~~~~

When binding with AdapterViews, RoboBinding first requires you to expose the underlying data from your presentation model. This can be in the form of an Array, List or ++org.robobinding.itempresentationmodel.TypedCursor++. From our previous example, we might well be exposing the superHeroes list.

As well as providing the data, RoboBinding needs to know the type of presentation model each child view of the AdapterView should bind onto. We declare this in our code with the @ItemPresentationModel annotation.
[source,java]
----
@ItemPresentationModel(SuperHeroPresentationModel.class)
public List<SuperHero> getSuperHeroes() {
	return superHeroes;
}
----
The class we use for our item presentation model will need to implement the ItemPresentationModel interface, parameterized to the type of data we are displaying at each index.
[source,java]
----
public class SuperHeroPresentationModel 
			implements ItemPresentationModel<SuperHero> {
	
	private SuperHero superHero;
	
	public void updateData(int index, SuperHero superHero) {
		this.superHero = superHero;
	}
}
----
We can then define a layout xml that will provide the view for each row in our AdapterView. A simple example (simple_super_hero_row.xml) might look like this:
[source,xml]
----
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:bind="http://robobinding.org/android"
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical" />
	  
	  <TextView android:layout_width="fill_parent"
	      android:layout_height="wrap_content"
	      bind:text="{superHeroName}" />
	      
	  <TextView android:layout_width="fill_parent"
	      android:layout_height="wrap_content"
	      bind:text="{superHeroCallSign}" />
	      
</LinearLayout>
----
The two bindings that we declared, superHeroName and superHeroCallSign, will need to be exposed from our item presentation model in the normal way.
[source,java]
----
public class SuperHeroPresentationModel 
			implements ItemPresentationModel<SuperHero> {
	
	private SuperHero superHero;
	
	public String getSuperHeroName() {
	    return superHero.getName();
	}
	
	public String getSuperHeroCallSign() {
	    return superHero.getCallSign();
	}
	
	public void updateData(int index, SuperHero superHero) {
		this.superHero = superHero;
	}
}
----
The last thing to do is to declare our ListView binding attributes in the layout xml, and we're done.
[source,xml]
----
<ListView android:layout_width="fill_parent"
	  android:layout_height="fill_parent"
	  bind:onItemClick="superHeroSelected"
	  bind:source="{superHeroes}"
	  bind:itemLayout="@layout/simple_super_hero_row" />
----

Featherweight relational cursor to object cursor mapping
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In link:#_binding_with_adapterviews[Binding with AdapterViews], we mentioned a data source type - ++org.robobinding.itempresentationmodel.TypedCursor++.
As we are so used to operating objects over relational data and tend to isolate the code that involves relational database operations, RoboBinding added a featherweight object Cursor - TypedCursor.
Through org.robobinding.itempresentationmodel.RowMapper<T>, we translate a row of relational data into an object. 
Continue with the example in link:#_binding_with_adapterviews[Binding with AdapterViews], we alter the data source type to TypedCursor<SuperHero>.
[source,java]
----
@ItemPresentationModel(SuperHeroPresentationModel.class)
public TypedCursor<SuperHero> getSuperHeroes() {
	allSuperHeroesQuery = new GetAllQuery<SuperHero>(SuperHero.TABLE_NAME, new SuperHeroRowMapper());
	return allSuperHeroesQuery.execute(db);
}
----
we add the class GetAllQuery:
[source,java]
----
public class GetAllQuery<T>
{
	private String tableName;
	private final RowMapper<T> rowMapper;

	public GetAllQuery(String tableName, RowMapper<T> rowMapper)
	{
	    this.tableName = tableName;
	    this.rowMapper = rowMapper;
	}

	public TypedCursor<T> execute(SQLiteDatabase db)
	{
		Cursor cursor = db.query(
				tableName,
				...,
				BaseColumns._ID+" ASC");
		return new org.robobinding.itempresentationmodel.TypedCursorAdapter<T>(cursor, rowMapper);
	}
}
----
and then we add the RowMapper implementation SuperHeroRowMapper:
[source,java]
----
public class SuperHeroRowMapper implements org.robobinding.itempresentationmodel.RowMapper<SuperHero> {

    @Override
    public SuperHero mapRow(Cursor cursor) {
	String name = cursor.getString(cursor.getColumnIndex(SuperHeroTable.NAME));
	String callSign = cursor.getString(cursor.getColumnIndex(SuperHeroTable.CALL_SIGN));
	return new SuperHero(name, callSign);
    }

}
----
That is it. An simple example of TypeCursor, org.robobinding.gallery.model.typedcursor, can be found under https://github.com/weicheng113/robobinding-gallery[RoboBinding Widget Gallery] project.

A Walk through Album Sample
---------------------------
Album Sample project is a translated version of Martin Fowler's http://martinfowler.com/eaaDev/PresentationModel.html[original one].
The source code can be found underneath https://github.com/RoboBinding/RoboBinding[RoboBinding project].

To import the project into Eclipse: File->Import->Android->Android Project from Existing Code->Browse and select robobinding-sample folder to import it.

.Album Sample project prototype
image::album_sample_prototype.png[]
The above is the prototype of the project. The project follows the standard RoboBinding project structure, comprising of an Activity class, layout xml and presentation model pojo.
Inside the project, you can see the following packages: org.robobinding.albumsample.activity, which contains all Activity classes;
org.robobinding.albumsample.presentationmodel, which contains all presentation models; org.robobinding.albumsample.model, which contains a Album entity implementation;
and org.robobinding.albumsample.store, which contains a AlbumStore implementation based on memory. In the prototype, you can see five diagrams.

The diagram [Home Activity] consists of org.robobinding.albumsample.activity.HomeActivity, home_activity.xml and org.robobinding.albumsample.presentationmodel.HomePresentationModel.

The diagram [View Albums Activity] consists of org.robobinding.albumsample.activity.ViewAlbumsActivity, view_albums_activity.xml and org.robobinding.albumsample.presentationmodel.ViewAlbumsPresentationModel;
and the view of each album item is backed by org.robobinding.albumsample.presentationmodel.AlbumItemPresentationModel and album_row.xml; when the album list is empty, albums_empty_view.xml is applied.

The diagram [Create Album Activity] and [Edit Album Activity] share the same components of org.robobinding.albumsample.activity.CreateEditAlbumActivity, create_edit_album_activity.xml and org.robobinding.albumsample.presentationmodel.CreateEditAlbumPresentationModel.

The diagram [View Album Activity] consists of org.robobinding.albumsample.activity.ViewAlbumActivity, view_album_activity.xml and org.robobinding.albumsample.presentationmodel.ViewAlbumPresentationModel;
and its album deletion dialog is backed by org.robobinding.albumsample.activity.DeleteAlbumDialog, delete_album_dialog.xml and DeleteAlbumDialogPresentationModel.

Take [View Albums Activity] as an example to give a brief explanation on source code.
The only thing the Activity class, ViewAlbumsActivity, does is to link the Layout file, view_albums_activity.xml and ViewAlbumsPresentationModel together.
view_albums_activity.xml contains three sub-views a TextView, a ListView and a Button. The TextView does not contain any binding information.
In the ListView, ++bind:source="\{albums\}"++ binds to ViewAlbumsPresentationModel.albums dataset property.
++bind:onItemClick="viewAlbum"++ binds to ViewAlbumsPresentationModel.viewAlbum(ItemClickEvent) method. When an album item is clicked, the method will be invoked.
++bind:emptyViewLayout="@layout/albums_empty_view"++ sets the display when album list is empty.
++bind:itemLayout="@layout/album_row"++ sets album item row layout, which will be bound to an ItemPresentationModel,
as indicated by the annotation, ++@ItemPresentationModel(AlbumItemPresentationModel.class)++, on top of the ViewAlbumsPresentationModel.albums property.
Inside the row layout file album_row.xml, there are two simple TextViews. Their ++bind:text="\{title\}"++ and ++bind:text="\{artist\}"++ bind to AlbumItemPresentationModel.title/artist respectively.
The last sub-view in view_albums_activity.xml is the Button. Its ++bind:onClick="createAlbum"++ binds to ViewAlbumsPresentationModel.createAlbum() method.


Create own attribute binding implementation
-------------------------------------------
Custom component
~~~~~~~~~~~~~~~~
We can implement attribute bindings for any custom components, third-party components or Android widgets to make them easier for use. 
In RoboBinding, the way to create an attribute binding implementation is consistent. 
When creating an own attribute binding implementation, we can refer to an existing one in RoboBinding, e.g., ++org.robobinding.viewattribute.imageview++ package and its ++ImageViewAttributeMapper++ class.

.custom Title Description Bar
image::custom_component.png[] 

Let us take a simple custom component, the view with white border above, as an example. The component consists of a title and a description. 
When we input new title and description, and click 'Apply', the component content will be updated accordingly.
The complete source code can be found in https://github.com/weicheng113/robobinding-gallery[RoboBinding Widget Gallery]. 

The major part of the source code for TitleDescriptionBar is shown below(for how to implement a custom component, 
please refer to http://developer.android.com/guide/topics/ui/custom-components.html[Android Reference]):
[source,java]
----
public class TitleDescriptionBar extends LinearLayout {
    private TextView title;
    private TextView description;

    public TitleDescriptionBar(Context context, AttributeSet attrs) {
		this(context, attrs, R.layout.title_description_bar);
    }

    protected TitleDescriptionBar(Context context, AttributeSet attrs, int layoutId) {
		super(context, attrs);

		LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		inflater.inflate(layoutId, this);
		title = (TextView) findViewById(R.id.title);
		description = (TextView) findViewById(R.id.description);
		...
    }

    public void setTitle(CharSequence titleText) {
		title.setText(titleText);
    }

    public void setDescription(CharSequence descriptionText) {
		description.setText(descriptionText);
    }
}
----
Its layout ++title_description_bar.xml++ below:
[source,xml]
----
<merge xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:bind="http://robobinding.org/android">
    <TextView android:id="@+id/title"/>
    <TextView android:text=": "/>
  	<TextView android:id="@+id/description"/>
----

We want the usage can be 'as simple as follows':
[source,xml]
----
<org.robobinding.gallery.model.customcomponent.TitleDescriptionBar
	    bind:title="{title}"
	    bind:description="{description}"/>
----
Implementing the binding attributes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The component has two binding attributes, TitleAttribute for the title and DescriptionAttribute for the description. 
And the BindingAttributeMapper, TitleDescriptionBarAttributeMapper, maps the attributes to its corresponding binding attribute implementations.
[source,java]
----
public class TitleAttribute implements PropertyViewAttribute<TitleDescriptionBar, CharSequence> {
    @Override
    public void updateView(TitleDescriptionBar view, CharSequence newText) {
		view.setTitle(newText);
    }
}

public class DescriptionAttribute implements PropertyViewAttribute<TitleDescriptionBar, CharSequence> {
    @Override
    public void updateView(TitleDescriptionBar view, CharSequence newText) {
		view.setDescription(newText);
    }
}

public class TitleDescriptionBarAttributeMapper implements BindingAttributeMapper<TitleDescriptionBar> {
    @Override
    public void mapBindingAttributes(BindingAttributeMappings<TitleDescriptionBar> mappings) {
        mappings.mapProperty(TitleAttribute.class, "title");
        mappings.mapProperty(DescriptionAttribute.class, "description");
    }
}
----
Registering the BindingAttributeMapper
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The BindingAttributeMapper can be registered through org.robobinding.binder.BinderFactoryBuilder.
[source,java]
----
BinderFactory binderFactory = new BinderFactoryBuilder()
        	.mapView(TitleDescriptionBar.class, new TitleDescriptionBarAttributeMapper())
        	.build();
ActivityBinder activityBinder = binderFactory.createActivityBinder(this, true);
activityBinder.inflateAndBind(R.layout.custom_component_activity, presentationModel);
----
That is done. We can create attribute binding implementations for any third-party components or Android widgets in the same approach.

Overriding an existing attribute binding implemenation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When an existing attribute binding implementation does not satisfy our requirement or some of binding attributes have not been implemented, we have two options. 
Firstly, we can directly modify the framework(we hope more people make contributions to the framework and help add more binding attributes). 
Alternatively, instead of modifying the framework, we implement new binding attributes and BindingAttributeMappers, and then register to replace the default implementations from framework.
Take the second approach as an example, we try to replace the existing http://developer.android.com/reference/android/widget/ImageView.html[ImageView] attribute binding implementation, ++org.robobinding.viewattribute.imageview++.

Implementing new binding attributes and a BindingAttributeMapper
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[source,java]
----
public class MyImageViewAttributeMapper implements BindingAttributeMapper<ImageView> {
    @Override
    public void mapBindingAttributes(BindingAttributeMappings<ImageView> mappings) {
		mappings.mapProperty(MyImageSourceAttribute.class, "src");
    }
}

public class MyImageSourceAttribute extends org.robobinding.widget.imageview.ImageSourceAttribute {
     @Override
    public PropertyViewAttribute<ImageView, ?> create(ImageView view, Class<?> propertyType) {
		if (String.class.isAssignableFrom(propertyType)) {
			return new UrlImageSourceAttribute();
		} else {
			return super.createPropertyViewAttribute(propertyType);
		}
    }

    static class UrlImageSourceAttribute implements PropertyViewAttribute<ImageView, Integer> {
		@Override
		public void updateView(ImageView view, String url) {
			Bitmap image = loadBitmapFromUrl(url);//load image from given url.
			view.setImageBitmap(image);
		}
	}
}
----

Register to replace the existing one
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[source,java]
----
BinderFactory binderFactory = new BinderFactoryBuilder()
        	.mapView(ImageView.class, new MyImageViewAttributeMapper())
        	.build();
----
Validator plugin
----------------
Updating... Please refer to link:old_validator_plugin.html[the old doc].

Other resources
---------------

*Jan 2012* Robert Taylor has written a couple of introductory articles http://roberttaylor426.blogspot.com/2011/11/hello-robobinding-part-1.html[here] and http://roberttaylor426.blogspot.com/2012/01/hello-robobinding-part-2.html[here].

*Feb 2012* A video of a talk on RoboBinding at SkillsMatter, London can be found http://skillsmatter.com/podcast/os-mobile-server/core-dev-talk-robobinding[here].

*RoboBinding Widget Gallery* Cheng Wei set up a https://github.com/weicheng113/robobinding-gallery[RoboBinding Widget Gallery] project to demonstrate usage of supported binding attributes.
