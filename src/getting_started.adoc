Getting Started
===============
:Revision: 0.8.5
:toc:
:numbered:
:imagesdir: ./images
:source-highlighter: pygments

What is RoboBinding?
--------------------
*Bind the gap* - RoboBinding is a data-binding presentation model framework for the Android platform. RoboBinding helps you write UI code that is easier to read, test and maintain.

Hello AndroidMVVM(Presentation Model)
-------------------------------------
An activity based on RoboBinding consists of third parts: layout xml, activity class and presentaton model class.
The sample code for the section is from https://github.com/RoboBinding/AndroidMVVM[AndroidMVVM].

Layout
~~~~~~
In layout files, we declare RoboBinding namespace, property and event attribute bindings.

activity_main.xml 
[source,xml]
----
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:bind="http://robobinding.org/android">
	<TextView
        bind:text="{hello}" />
		...
	<Button 
        android:text="Say Hello"
        bind:onClick="sayHello"/>
</LinearLayout>		
----

Presentation Model
~~~~~~~~~~~~~~~~~~
In presentation models, we declare corresponding properties and methods.

org.robobinding.androidmvvm.PresentationModel.java 
[source,java]
----
public class PresentationModel extends AbstractPresentationModel {
    private String name;
    public String getHello() {
		return name + ": hello Android MVVM(Presentation Model)!";
    }
    ...
    public void sayHello() {
		firePropertyChange("hello");
    }
}
----

Activity Class
~~~~~~~~~~~~~~
Activities bind layouts and presentation models together with the help of RoboBinding.

org.robobinding.androidmvvm.MainActivity.java 
[source,java]
----
public class MainActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
		...
		PresentationModel presentationModel = new PresentationModel();
		View rootView = Binders.inflateAndBindWithoutPreInitializingViews(this, R.layout.activity_main, presentationModel);
		setContentView(rootView);
    }
}
----

The simplest AndroidMVVM is done. We use the utility class ++Binders++ for simplicity here. 
In read-world applications, we recommend using ++org.robobinding.binder.BinderFactoryBuilder++ instead.
We can keep the BinderFactory instance in Android application or let a third-party library like https://github.com/roboguice/roboguice[RoboGuice] manage the BinderFactory instance,
so that we can share and reuse the instance over the whole application.

Introduction videos
~~~~~~~~~~~~~~~~~~~~~
* ++Feb 2012++ A video of a talk on RoboBinding by Robert Taylor at SkillsMatter, London can be found http://skillsmatter.com/podcast/os-mobile-server/core-dev-talk-robobinding[here].
* ++July 2014++ A video of a talk ++in Chinese++ on RoboBinding by Cheng Wei can be found https://www.youtube.com/watch?v=2sSBVaX77xA[here].

Environment Setup
-----------------

Eclipse
~~~~~~~
Install http://eclipse.org/[Eclipse].

Without AspectJ
^^^^^^^^^^^^^^^
Add the 'robobinding-[xxx].jar' to the libs folder of your project, then add it to your classpath by right-clicking on your project→Properties→Java Build Path→Libraries→Add JARs. 
In Order and Export tab, check the 'robobinding-[xxx].jar'.

With AspectJ
^^^^^^^^^^^^
RoboBinding aspects will reduce the work by auto weaving in some source code. 
If we want to take the advantage, firstly get http://developer.android.com/tools/sdk/eclipse-adt.html[Android Development Tools] plugin installed.
Once having it installed, right-click on the project→Configure→Convert to AspectJ Project. This will add the AspectJ natures to your .project file.

Start by adding either the 'robobinding-[xxx]-jar-with-dependencies.jar' or the 'robobinding-[xxx].jar' plus AspectJ Runtime Library to the libs folder of your project, 
then add it(or them) to your classpath by right-clicking on your project→Properties→Java Build Path→Libraries→Add JARs. 
In Order and Export tab, check it(them).

Finally, make sure the RoboBinding jar is added to your project Aspect Path. Right click on your project→Properties→AspectJ Build→Aspect Path→Add JARs.

.An example using robobinding-[xxx]-jar-with-dependencies.jar
image::eclipse_project_build_settings.png["Eclipse project build settings"]

Please feel free to take a look at https://github.com/RoboBinding/RoboBinding/[RoboBinding album sample] as reference.

Android Studio
~~~~~~~~~~~~~~
Please refer to the build file https://github.com/weicheng113/album-sample_AndroidStudio/[here] for now.

ProGuard
~~~~~~~~
RoboBinding requires that all classes which implement org.robobinding.property.ObservableBean (i.e. presentation models) have their names and public methods left intact. Additionally, we need to preserve all annotations.

To achieve this, add the following directives to your ProGuard configuration:
[source,erlang]
----
-keep class * implements org.robobinding.property.ObservableBean {
	public *** *(...);
}

-keepattributes *Annotation*,Signature
----

And add the following lines also to keep the constructors of view listeners.
[source,erlang]
----
-keepclassmembers class * extends org.robobinding.widget.view.ViewListeners {
	public <init>(...);
}
----

And add the following lines to avoid some android sdk back compatibility warnings.
[source,erlang]
----
-dontwarn android.widget.AbsListView, android.view.View
----

Examples of proguard.cfg settings can be found in https://github.com/RoboBinding/RoboBinding/[RoboBinding album sample] and https://github.com/RoboBinding/RoboBinding-gallery/[Robobinding Gallery].

Concepts and Features
---------------------
.A RoboBinding-based Android application
image::robobinding_based_app.png[]

An Android application contains several Activities and other elements. In a RoboBinding-based Android application, an Activity contains an Activity class, a layout xml and a PresentationModel pojo
(Whereas in an ordinary Android application, an Activity contains only an Activity class and a layout xml). The display logic, which was originally sit inside the Activity class, is extracted into a separate PresentationModel pojo.
Activities will utilize RoboBinding to bind layouts to its corresponding display logic PresentationModel. The display data of a layout is bound to the properties of a PresentationModel,
 while the view events of a layout are bound to the methods of a PresentationModel. RoboBinding helps to reduce or remove the UI code in original Activity class through simple binding declarations in layout files.
 Ideally a PresentationModel only contains UI display logic, not UI code or UI wiring code, and can be tested independently and easily.

The sample code for the section is from https://github.com/RoboBinding/RoboBinding-gallery/[Robobinding Gallery].

One-way property binding
~~~~~~~~~~~~~~~~~~~~~~~~
When we bind to a property on the presentation model, any changes made to that property are automatically propagated to the view.

activity_view.xml
[source,xml]
----
<TextView
    bind:visibility="{integerVisibility}"/>
----

ViewPresentationModel.java
[source,java]
----
public int getIntegerVisibility() {
	return integerVisibilityRotation.value();
}
----
RoboBinding adheres to the JavaBeans specification whereby to expose properties, we provide public getters and setters.
With one-way binding, only getters are required, as the changes from view are not updated back to presentation models.
For supported UI binding attributes, please refer to ++API and Binding Attributes JavaDocs++.

Two-way property binding
~~~~~~~~~~~~~~~~~~~~~~~~
Two-way binding takes property binding one step further, and ensures that as well as propagating changes from the presentation model to the view, any changes to the view are also synched back to the presentation model.

EditText fields are one of the UI elements that support two-way binding. In this case, whenever a text change is made by the user, the presentation model is updated accordingly.

To use two-way binding, we simply prepend a dollar ($) sign before the curly braces we used in our one-way binding declaration, like so:

activity_edittext.xml
[source,xml]
----
<EditText 
	bind:text="${text}"/>
----

That's the only thing we have to do. Note that in the case of two-way binding, we would need to have given RoboBinding write-access to the property, so supplying a setter method on our presentation model is compulsory.

org.robobinding.gallery.presentationmodel.EditTextPresentationModel.java
[source,java]
----
@PresentationModel
public class EditTextPresentationModel {
    private String text;
    
    public String getText() {
		return text;
    }
    
    public void setText(String text) {
		this.text = text;
    }
}
----

Event handling
~~~~~~~~~~~~~~
Bind view events to presentation model methods.

activity_gallery.xml
[source,xml]
----
<Button 
	bind:onClick="showDemo"/>
----

org.robobinding.gallery.presentationmodel.GalleryPresentationModel.java
[source,java]
----
@PresentationModel
public class GalleryPresentationModel
{
	...
	public void showDemo()
	{
		...
	}
}
----
When onClick event is fired, showDemo() method will be invoked. We can optionally supply an event parameter, 
it will be a org.robobinding.widget.view.ClickEvent in this case.

For supported UI events, please refer to ++API and Binding Attributes JavaDocs++.

Binding with AdapterViews
~~~~~~~~~~~~~~~~~~~~~~~~~
When binding with AdapterViews, RoboBinding first requires you to expose the underlying data from your presentation model. 
This can be in the form of an Array, List or ++org.robobinding.itempresentationmodel.TypedCursor++. 

As well as providing the data, RoboBinding needs to know the type of presentation model each child view of the AdapterView should bind onto. 
We declare this in our code with the @ItemPresentationModel annotation.


activity_adapter_view.xml
[source,xml]
----
<ListView
	bind:itemLayout="@android:layout/simple_list_item_1"
	bind:itemMapping="[text1.text:{value}]"
	bind:source="{dynamicStrings}"/>
----

org.robobinding.gallery.presentationmodel.AdapterViewPresentationModel.java
[source,java]
----
@PresentationModel
public class AdapterViewPresentationModel
{
	...
	@ItemPresentationModel(value=StringItemPresentationModel.class)
	public List<String> getDynamicStrings()
	{
		return getSelectedSource().getSample();
	}
----

The class we use for our item presentation model will need to implement the ItemPresentationModel interface, parameterized to the type of data we are displaying at each index.

org.robobinding.gallery.presentationmodel.StringItemPresentationModel.java
[source,java]
----
public class StringItemPresentationModel implements ItemPresentationModel<String>
{
	private String value;

	@Override
	public void updateData(int index, String bean)
	{
		value = bean;
	}

	public String getValue()
	{
		return value;
	}
}
----

We can then define a layout xml that will provide the view for each row in our AdapterView. 
In the example, we use the Android predefined item layout simple_list_item_1.xml. 
Through ++bind:itemMapping="[text1.text:\{value\}]"++, we map text1.text from simple_list_item_1.xml to StringItemPresentationModel.value.

Featherweight relational cursor to object cursor mapping
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In ++Binding with AdapterViews++, we mentioned a data source type - ++org.robobinding.itempresentationmodel.TypedCursor++.
As we are so used to operating objects over relational data and want to isolate the code that involves relational database operations, RoboBinding added a featherweight object Cursor - TypedCursor.
Through org.robobinding.itempresentationmodel.RowMapper<T>, we translate a row of relational data into an object. 

org.robobinding.gallery.presentationmodel.TypedCursorPresentationModel.java
[source,java]
----
@PresentationModel
public class TypedCursorPresentationModel {
    ...
    @ItemPresentationModel(value=ProductItemPresentationModel.class)
    public TypedCursor<Product> getProducts() {
		return allProductsQuery.execute(db);
    }
}
----

org.robobinding.gallery.model.typedcursor.GetAllQuery.java
[source,java]
----
public class GetAllQuery<T>
{
	private String tableName;
	private final RowMapper<T> rowMapper;

	public GetAllQuery(String tableName, RowMapper<T> rowMapper)
	{   
	    ...
		this.tableName = tableName;
	    this.rowMapper = rowMapper;
	}

	public TypedCursor<T> execute(SQLiteDatabase db)
	{
		Cursor cursor = db.query(
				tableName,
				null,
				null,
				null,
				null,
				null,
				BaseColumns._ID+" ASC");
		return new TypedCursorAdapter<T>(cursor, rowMapper);
	}
}
----

org.robobinding.gallery.model.typedcursor.ProductRowMapper.java
[source,java]
----
public class ProductRowMapper implements RowMapper<Product> {

    @Override
    public Product mapRow(Cursor cursor) {
		String name = cursor.getString(cursor.getColumnIndex(ProductTable.NAME));
		String description = cursor.getString(cursor.getColumnIndex(ProductTable.DESCRIPTION));
		return new Product(name, description);
    }

}
----

Menu Binding
~~~~~~~~~~~~
Bind menu resources in res/menu to Presentation Models. Let us have a look at a simple example below.

res/menu/context_menu.xml
[source,xml]
----
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:bind="http://robobinding.org/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <item android:title="Delete Product"
          bind:onMenuItemClick="deleteProduct"
          android:id="@+id/deleteProduct"
          app:showAsAction="always"/>

</menu>
----

org.robobinding.gallery.presentationmodel.ContextMenuPresentationModel.java
[source,java]
----
@PresentationModel
public class ContextMenuPresentationModel {
    ...    
    public void deleteProduct(MenuItem menuItem) {
		...
    }
}
----

Presentation Models
~~~~~~~~~~~~~~~~~~~
There are two way to implement Presentation Models.

* Annotate Presentation Model classes with the AspectJ annotation @org.robobinding.aspects.PresentationModel.
The advantage of the approach is that Presentation Models don't have to extend an extra super class or interface 
and some source code will be automatically weaved in to reduce the work.
The disadvantage is that there is a dependency on AspectJ Runtime Library.

* Let Presentation Models extends org.robobinding.presentationmodel.AbstractPresentationModel or implements org.robobinding.property.ObservableBean.
The advantage is that there is no extra dependency on AspectJ. 
The disadvantage is that Presentation Models have to extend or implement the class/interface above, as well as having to manually type in everything, e.g., firePropertyChange("propertyName").

A Walk through Album Sample
---------------------------
Album Sample project is a translated version of Martin Fowler's http://martinfowler.com/eaaDev/PresentationModel.html[original one].
The source code can be found underneath https://github.com/RoboBinding/RoboBinding[RoboBinding project].

To import the project into Eclipse: File->Import->Android->Android Project from Existing Code->Browse and select robobinding-sample folder to import it.

.Album Sample project prototype
image::album_sample_prototype.png[]

In the following section, a package start with '.' is a relative path to org.robobinding.albumsample.

The above is the prototype of the project. The project follows the standard RoboBinding project structure, comprising of an Activity class, layout xml and presentation model pojo.
Inside the project, you can see the following packages: org.robobinding.albumsample.activity, which contains all Activity classes;
org.robobinding.albumsample.presentationmodel, which contains all presentation models; org.robobinding.albumsample.model, which contains a Album entity implementation;
and org.robobinding.albumsample.store, which contains a AlbumStore implementation based on memory. In the prototype, you can see five diagrams.

The diagram [Home Activity] consists of .activity.HomeActivity, home_activity.xml and .presentationmodel.HomePresentationModel.

The diagram [View Albums Activity] consists of .activity.ViewAlbumsActivity, view_albums_activity.xml and .presentationmodel.ViewAlbumsPresentationModel;
and the view of each album item is backed by .presentationmodel.AlbumItemPresentationModel and album_row.xml; when the album list is empty, albums_empty_view.xml is applied.

The diagram [Create Album Activity] and [Edit Album Activity] share the same components of .activity.CreateEditAlbumActivity, create_edit_album_activity.xml and .presentationmodel.CreateEditAlbumPresentationModel.

The diagram [View Album Activity] consists of .activity.ViewAlbumActivity, view_album_activity.xml and .presentationmodel.ViewAlbumPresentationModel;
and its album deletion dialog is backed by .activity.DeleteAlbumDialog, delete_album_dialog.xml and .presentationmodel.DeleteAlbumDialogPresentationModel.

Take [View Albums Activity] as an example to give a brief explanation on source code.
The only thing the Activity class, ViewAlbumsActivity, does is to link the Layout view_albums_activity.xml and ViewAlbumsPresentationModel together.
view_albums_activity.xml contains three sub-views a TextView, a ListView and a Button. The TextView does not contain any binding information.
In the ListView, ++bind:source="\{albums\}"++ binds to ViewAlbumsPresentationModel.albums dataset property.
++bind:onItemClick="viewAlbum"++ binds to ViewAlbumsPresentationModel.viewAlbum(ItemClickEvent) method. When an album item is clicked, the method will be invoked.
++bind:emptyViewLayout="@layout/albums_empty_view"++ sets the display when album list is empty.
++bind:itemLayout="@layout/album_row"++ sets album item row layout, which will be bound to an ItemPresentationModel,
as indicated by the annotation, ++@ItemPresentationModel(AlbumItemPresentationModel.class)++, on top of the ViewAlbumsPresentationModel.albums property.
Inside the row layout file album_row.xml, there are two simple TextViews. Their ++bind:text="\{title\}"++ and ++bind:text="\{artist\}"++ bind to AlbumItemPresentationModel.title/artist respectively.
The last sub-view in view_albums_activity.xml is the Button. Its ++bind:onClick="createAlbum"++ binds to ViewAlbumsPresentationModel.createAlbum() method.

Contents of Gallery Demos
-------------------------
The entry classes mentioned below are from the package org.robobinding.gallery.activity of https://github.com/RoboBinding/RoboBinding-gallery/[Robobinding Gallery] project.

* Binding attributes demo for View. The entry class is ViewActivity.

* Binding attributes demo for EditText. The entry class is EditTextActivity.

* Binding attributes demo for AdapterView. The entry class is AdapterViewActivity.

* Binding attributes demo for ListView. The entry class is ListViewActivity.

* Binding attributes demo for Custom Components. The entry class is CustomComponentActivity.

* Demo for Object Cursor. The entry class is TypedCursorActivity.

* Demo for Dynamic Binding. The entry class is DynamicBindingActivity.

* Demo for PresentationModel implementation by Subclassing without AspectJ. The entry class is BySubclassNoAspectJActivity.

* Demo for PresentationModel implementation by Implementing Interface without AspectJ. The entry class is ByInterfaceNoAspectJActivity.

* Demo for Fragment & ViewPager Binding. The entry class is ListFragmentDemoActivity.

* Demo for Options Menu Binding. The entry class is OptionsMenuActivity.

* Demo for Context Menu Binding. The entry class is ContextMenuDemoActivity.

* Demo for Contextual Action Mode Binding. The entry class is ContextualActionModeActivity.

Create own view binding implementation
--------------------------------------
The sample code for the section is from https://github.com/RoboBinding/RoboBinding-gallery/[Robobinding Gallery].

There are two ways available to implement a view binding, ++Static++ view binding and ++Dynamic++ view binding.
Static view binding approach targets for commonly-used view attributes, 
whereas dynamic view binding acts as a supplement to quickly create attribute bindings when they are not implemented by RoboBinding.

Custom component or third-party component
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We can create view bindings for any custom components, third-party components or Android widgets to make them easier for use. 
In RoboBinding, the way to create an view binding implementation is consistent. 
When creating an own view binding implementation, we can refer to an existing one in RoboBinding, e.g., ++org.robobinding.widget.imageview++ package and its ++ImageViewBinding++ class.

.custom Title Description Bar
image::custom_component.png[] 

Let us take a simple custom component, the view with white border above, as an example. The component consists of a title and a description. 
When we input new title and description, and click 'Apply', the component content will be updated accordingly.

We want the usage can be 'as simple as follows':

activity_custom_component.xml
[source,xml]
----
<org.robobinding.gallery.model.customcomponent.TitleDescriptionBar
	    bind:title="{title}"
	    bind:description="{description}"/>
----

The major part of the source code for TitleDescriptionBar is shown below(for how to implement a custom component, 
please refer to http://developer.android.com/guide/topics/ui/custom-components.html[Android Reference]):
[source,java]
----
public class TitleDescriptionBar extends LinearLayout {
    private TextView title;
    private TextView description;

    public TitleDescriptionBar(Context context, AttributeSet attrs) {
		this(context, attrs, R.layout.title_description_bar);
    }

    protected TitleDescriptionBar(Context context, AttributeSet attrs, int layoutId) {
		super(context, attrs);

		LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		inflater.inflate(layoutId, this);
		title = (TextView) findViewById(R.id.title);
		description = (TextView) findViewById(R.id.description);
		...
    }

    public void setTitle(CharSequence titleText) {
		title.setText(titleText);
    }

    public void setDescription(CharSequence descriptionText) {
		description.setText(descriptionText);
    }
}
----
Its layout ++title_description_bar.xml++ below:
[source,xml]
----
<merge xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:bind="http://robobinding.org/android">
    <TextView android:id="@+id/title"/>
    <TextView android:text=": "/>
  	<TextView android:id="@+id/description"/>
----

Implementing the binding attributes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The component has two binding attributes, TitleAttribute for the title and DescriptionAttribute for the description. 
And the ViewBinding, TitleDescriptionBarBinding, maps the attributes to its corresponding binding attribute implementations.
[source,java]
----
public class TitleAttribute implements PropertyViewAttribute<TitleDescriptionBar, CharSequence> {
    @Override
    public void updateView(TitleDescriptionBar view, CharSequence newText) {
		view.setTitle(newText);
    }
}

public class DescriptionAttribute implements PropertyViewAttribute<TitleDescriptionBar, CharSequence> {
    @Override
    public void updateView(TitleDescriptionBar view, CharSequence newText) {
		view.setDescription(newText);
    }
}

public class TitleDescriptionBarBinding implements ViewBinding<TitleDescriptionBar> {
    @Override
    public void mapBindingAttributes(BindingAttributeMappings<TitleDescriptionBar> mappings) {
        mappings.mapProperty(TitleAttribute.class, "title");
        mappings.mapProperty(DescriptionAttribute.class, "description");
    }
}
----

Registering ViewBindings
^^^^^^^^^^^^^^^^^^^^^^^^
ViewBindings can be registered through org.robobinding.binder.BinderFactoryBuilder.

org.robobinding.gallery.activity.CustomComponentActivity.java
[source,java]
----
BinderFactory binderFactory = new BinderFactoryBuilder()
        	.mapView(TitleDescriptionBar.class, new TitleDescriptionBarBinding())
        	.build();
ActivityBinder activityBinder = binderFactory.createActivityBinder(this, true);
activityBinder.inflateAndBind(R.layout.custom_component_activity, presentationModel);
----

It is done. We can create view binding implementations for any third-party components or Android widgets in the same approach.

Overriding an existing view binding implemenation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When an existing view binding implementation does not satisfy our requirement or some of binding attributes have not been implemented, we have two options. 
Firstly, we can directly modify the framework(we hope more people make contributions to the framework and help add more binding attributes). 
Alternatively, instead of modifying the framework, we implement new ViewBindings and their binding attributes, and then register to replace the default implementations from framework.
Take the second approach as an example, we try to replace the existing http://developer.android.com/reference/android/widget/ImageView.html[ImageView] view binding implementation, ++org.robobinding.widget.imageview++.

Implementing new ViewBinding and binding attributes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[source,java]
----
public class MyImageViewBinding extends org.robobinding.widget.imageview.ImageViewBinding {
    @Override
    public void mapBindingAttributes(BindingAttributeMappings<ImageView> mappings) {
		mappings.mapProperty(MyImageSourceAttribute.class, "src");
    }
}

public class MyImageSourceAttribute extends org.robobinding.widget.imageview.ImageSourceAttribute {
     @Override
    public PropertyViewAttribute<ImageView, ?> create(ImageView view, Class<?> propertyType) {
		if (String.class.isAssignableFrom(propertyType)) {
			return new UrlImageSourceAttribute();
		} else {
			return super.createPropertyViewAttribute(propertyType);
		}
    }

    static class UrlImageSourceAttribute implements PropertyViewAttribute<ImageView, Integer> {
		@Override
		public void updateView(ImageView view, String url) {
			Bitmap image = loadBitmapFromUrl(url);//load image from given url.
			view.setImageBitmap(image);
		}
	}
}
----

Register to replace the existing one
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[source,java]
----
BinderFactory binderFactory = new BinderFactoryBuilder()
        	.mapView(ImageView.class, new MyImageViewBinding())
        	.build();
----

Dynamic view binding
~~~~~~~~~~~~~~~~~~~~
When RoboBinding has not implemented some attribute bindings, with dynamic view binding we can quickly implement new or extend existing view bindings. 
Dynamic view binding acts as a supplement to static view binding.

Create a new view binding
^^^^^^^^^^^^^^^^^^^^^^^^^
Create a new dynamic view binding for CustomOrThirdPartyComponent and add the attribute binding for textAttribute.

activity_dynamic_binding.xml
[source,xml]
----
<org.robobinding.gallery.model.dynamicbinding.CustomOrThirdPartyComponent 
	bind:textAttribute="{textAttributeValue}"/>
----

org.robobinding.gallery.activity.DynamicBindingActivity.java
[source,java]
----
public class DynamicBindingActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
		...
		BinderFactoryBuilder binderFactoryBuilder = new BinderFactoryBuilder()
			.add(new DynamicViewBinding().forView(CustomOrThirdPartyComponent.class)
				.oneWayProperties("textAttribute"));
		BinderFactory binderFactory = binderFactoryBuilder.build();
		ActivityBinder activityBinder = binderFactory.createActivityBinder(this, true);
		activityBinder.inflateAndBind(R.layout.activity_dynamic_binding, presentationModel);
    }
	...
}
----

Extend an existing view binding
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Extend the existing TextViewBinding and add the attribute binding for typeface.

activity_dynamic_binding.xml
[source,xml]
----
<TextView
	bind:typeface="{typeface}"/>
----

org.robobinding.gallery.activity.DynamicBindingActivity.java
[source,java]
----
public class DynamicBindingActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
		...
		BinderFactoryBuilder binderFactoryBuilder = new BinderFactoryBuilder()
			.add(new DynamicViewBinding().extend(TextView.class, new TextViewBinding())
				.oneWayProperties("typeface"));
		BinderFactory binderFactory = binderFactoryBuilder.build();
		ActivityBinder activityBinder = binderFactory.createActivityBinder(this, true);
		activityBinder.inflateAndBind(R.layout.activity_dynamic_binding, presentationModel);
    }
	...
}
----

Project structure and best practices
------------------------------------
Involved from MVC pattern, the major motive of Presentation Model(MVVM) pattern is to make Presentation Models pure POJOs, which can be 
easily Unit tested. Meanwhile, the dependency of View->Presentation Model->Model becomes unidirectional. 
When applying the pattern, these are the basic rules we will follow. https://github.com/RoboBinding/RoboBinding[Album Sample] is an example that follows the best practices.
Recommend to read Martin Fowler's original article of http://martinfowler.com/eaaDev/PresentationModel.html[Presentation Model].

Overall project structure
~~~~~~~~~~~~~~~~~~~~~~~~~
.Project structure
image::project_structure.png["Project structure"]

In Android app, the view layer consists of activities and their layouts and the model layer(or business model layer) consists of various services, 
persistence layer, networking services, business services and so on.
The diagram indicates the dependency between different layers. The view layer for example never directly accesses the business model.

The solutions for some common design issues
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* When we are not using a third-party dependency injection lib, we may instantiate business model objects in Activities and then pass them into presentation models,
 but the view layer(or any activities) will not directly access any business model objects.

* Sometimes presentation models may need to call some functionalities in the view layer. We can add view interfaces in between to decouple the relationship.
Presentation models depends on view interfaces instead of the view layer, which keeps the testability of presentation models. 
If you prefer, you can shift view interfaces into presentation model layer or presentation model package, so that the dependency remains unidirectional.
Let us have a look a simple example below:

[source,java]
----
interface MainView {
	void doSomeViewLogic();
}

class MainActivity extends Activity implements MainView {
	...
	@Override
    protected void onCreate(Bundle savedInstanceState) {
		...
		PresentationModel presentationModel = new PresentationModel(this);
		...
	}
	
	public void doSomeViewLogic() {
		...
	}
}

class PresentationModel {
	private MainView mainView;
	
	public PresentationModel(MainView mainView) {
		this.mainView = mainView;
	}
	
	public void someEvent() {
		mainView.doSomeViewLogic();
	}
}
----

Other resources
---------------

*Jan 2012* Robert Taylor has written a couple of introductory articles http://roberttaylor426.blogspot.com/2011/11/hello-robobinding-part-1.html[here] and http://roberttaylor426.blogspot.com/2012/01/hello-robobinding-part-2.html[here].

*Feb 2012* A video of a talk on RoboBinding at SkillsMatter, London can be found http://skillsmatter.com/podcast/os-mobile-server/core-dev-talk-robobinding[here].

*RoboBinding Gallery* Cheng Wei set up https://github.com/RoboBinding/RoboBinding-gallery[RoboBinding Gallery] project to demonstrate RoboBinding features.
