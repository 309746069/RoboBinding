入门
====
:Revision: 0.8.2
:toc:
:numbered:
:imagesdir: ./images
:source-highlighter: pygments

RoboBinding是什么?
------------------
*Android应用的粘接剂* - RoboBinding是一个实现了数据绑定 http://martinfowler.com/eaaDev/PresentationModel.html[Presentation Model] 模式的Android开源框架。RoboBinding 帮助你编写更可读，易于测试与维护的UI代码。

属性绑定
~~~~~~~~

在layout xml里声明一个属性绑定:
[source,xml]
----
<EditText android:layout_width="fill_parent"
	  android:layout_height="wrap_content"
	  bind:text="${superHeroName}" />
----

增加一个 http://baike.baidu.com/view/183175.htm[pojo] presentation model 类并提供相应的属性:
[source,java]
----
public void setSuperHeroName(String superHeroName) {
	this.superHeroName = superHeroName;
}

public String getSuperHeroName() {
	return superHeroName;
}
----
RoboBinding 将自动的同步View与Presentation Model。

事件处理
~~~~~~~~

在layout xml里声明一个事件绑定:
[source,xml]
----
<ListView android:layout_width="fill_parent"
	  android:layout_height="fill_parent"
	  bind:onItemClick="superHeroSelected" />
----

增加一个 http://baike.baidu.com/view/183175.htm[pojo] presentation model 类并提供相应的事件处理方法:
[source,java]
----
public void superHeroSelected(ItemClickEvent event) {
	SuperHero chosenSuperHero = this.superHeroes.get(event.getPosition());
	chosenSuperHero.summon();
}
----
当item click 事件被触发时，RoboBinding 将自动调用相应的方法。

Hello RoboBinding
-----------------
让我们观看由Robert Taylor做的http://skillsmatter.com/podcast/os-mobile-server/core-dev-talk-robobinding[框架介绍视频]。

开发环境
~~~~~~~~
Eclipse
^^^^^^^
首先安装http://eclipse.org/[Eclipse] 与 http://developer.android.com/tools/sdk/eclipse-adt.html[Android Development Tools(ADT)]插件。
然后把'robobinding-[xxx].jar' 或 'robobinding-[xxx]-jar-with-dependencies.jar'加入项目的lib或libs目录，右击项目->Properties->Java Build Path->Libraries->Add Jars，将jar加入classpath。
如果选择的是'robobinding-[xxx].jar'，还需要将https://code.google.com/p/guava-libraries/[guava] 11.0.1+ jar加入项目的classpath。

RoboBinding通过AspectJ aspects来自动的为presentation model添加属性变更通知代码。如果想要这个功能的话(推荐的方式)，需要安装http://www.eclipse.org/ajdt/[AspectJ Development Tools (AJDT)]插件。

当AJDT安装好后，右击项目->Configure->Convert to AspectJ Project。AspectJ natures将被添加到项目的.project文件。

然后确认AspectJ Runtime Library将被包含入构建包，右击项目->Properties->Java Build Path->Order and Export，确认AspectJ Runtime Library已经被勾选。

最后确认 RoboBinding jar在Aspect路径里，右击项目->Properties->AspectJ Build->Aspect Path->Add JARs。

.Eclipse project build settings
image::eclipse_project_build_settings.png["Eclipse project build settings"]

请参考https://github.com/RoboBinding/RoboBinding/[RoboBinding album sample]环境设置。

Android Studio
^^^^^^^^^^^^^^
Gradle的build file请参考https://github.com/weicheng113/album-sample_AndroidStudio/[这里]。

ProGuard
^^^^^^^^
RoboBinding需要所有实现了org.robobinding.property.ObservableProperties(如所有的presentation model)类的类名与公共方法保持不变。保留所有的annoations。
所以需要在项目的ProGuard配置里加入下面的指令：
[source,erlang]
----
-keep class * implements org.robobinding.property.ObservableProperties {
	public *** *(...);
}

-keepattributes *Annotation*,Signature
----

从版本0.8.1开始，RoboBinding依赖于guava类库。目前guava在进行ProGuard时候有些问题，所以需要增加以下的内容：
----
-dontwarn com.google.common.collect.MinMaxPriorityQueue
-dontwarn sun.misc.Unsafe
----

最后增加以下的内容，使ProGuard保留view listeners的构造函数名：
[source,erlang]
----
-keepclassmembers class * extends org.robobinding.viewattribute.view.ViewListeners {
	public <init>(...);
}
----

请参考https://github.com/RoboBinding/RoboBinding/[RoboBinding album sample]下的ProGuard配置文件proguard.cfg。

Maven
^^^^^
更新中。。。 请参考link:old_maven.html[旧文档]

配置Activity
~~~~~~~~~~~~
在大多的情况下，我们在Activity class里将layout xml与其presentation model绑定在一起。一般情况下，一个Activity对应一个presenation model。
在Activity class的OnCreate()方法，使用++org.robobinding.binder.Binders++ 工具类或++org.robobinding.binder.BinderFactory++(由org.robobinding.binder.BinderFactoryBuilder创建。可以将BinderFactory保存在http://developer.android.com/reference/android/app/Application.html[android.app.Application] 
或dependency injection库如https://github.com/roboguice/roboguice[RoboGuice]里，以便重用实例)将layout xml绑定到presentation model实例。 例如：
[source,java]
----
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    SuperHeroPresentationModel presentationModel = new SuperHeroPresentationModel();
    Binders.bind(this, R.layout.super_hero_activity, presentationModel);
}
----
你可能注意到，不用再调用setContentView()方法，RoboBinding已经为你做了。

声明RoboBinding命名空间
~~~~~~~~~~~~~~~~~~~~~~~
在使用RoboBonding绑定属性前，需要在每个layout xml的根结点声明RoboBinding命名空间。例如，在示例super_hero_activity.xml里，我们加入以下片段：
[source,xml]
----
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:bind="http://robobinding.org/android"
    android:layout_width="fill_parent"
    android:layout_height="wrap_content" >
    
    ...
    
</RelativeLayout>
----
属性绑定
~~~~~~~~
当一个视图属性被绑定到相应presentation model的属性上时，presentation model的那个属性值的任何变更都会自动同步到视图上。
RoboBinding遵循JavaBeans规范，当要暴露superHeroName属性时，我们提供对应的公共getters与setters。
[source,java]
----
private String superHeroName;

public String getSuperHeroName() {
    return superHeroName;
}

public void setSuperHeroName(String superHeroName) {
    this.superHeroName = superHeroName;
}
----
然后我们将视图属性绑定到该presentation model属性，以TextView为例。
[source,xml]
----
<TextView android:layout_width="fill_parent"
	  android:layout_height="wrap_content"
	  bind:text="{superHeroName}" />
----
因为以上只是一个单向绑定，所以只要提供getter方法就好了。
[source,java]
----
public String getSuperHeroName() {
    return "Powdered Toast Man!";
}
----
更多的已支持的绑定属性信息，请参考 https://oss.sonatype.org/service/local/repositories/releases/archive/org/robobinding/robobinding/0.8.2/robobinding-0.8.2-javadoc.jar/!/index.html[API与支持的绑定属性JavaDocs]

双向属性绑定
~~~~~~~~~~~~
单向属性绑定只是将presentation model属性的变更同步到视图上，而双向绑定增加了将视图上的变更同步到presentation model属性上。

EditText是一个支持双向绑定的例子，当用户更新EditText上的内容时，新的内容将被同步到presentation model上。

通过在视图属性前加上++$++，声明为双向绑定，例如：
[source,java]
----
<EditText android:layout_width="fill_parent"
	  android:layout_height="wrap_content"
	  bind:text="${superHeroName}" />
----
当将属性声明为双向绑定时，presentation model的对应属性必须有setter方法，以便于视图的更新值被设置到presentation model属性上。

事件处理
~~~~~~~~
为了将更多视图逻辑从Activity class中剥离出来，RoboBinding推荐并支持在presentation model里处理UI事件。不同的视图有不同的UI事件，
对于已支持的UI事件，请参考https://oss.sonatype.org/service/local/repositories/releases/archive/org/robobinding/robobinding/0.8.2/robobinding-0.8.2-javadoc.jar/!/index.html[API与支持的绑定属性JavaDocs]。

在视图里声明事件处理器与声明视图属性绑定相似，以下在ListView里声明onItemClick事件处理(继承于AdapterView)：
[source,java]
----
<ListView android:layout_width="fill_parent"
	  android:layout_height="fill_parent"
	  bind:onItemClick="superHeroSelected" />
----
当onItemClick事件触发时，presentation model对应的superHeroSelected方法将被调用。相应的事件实例，这里是org.robobinding.viewattribute.adapterview.ItemClickEvent，将被作为参数传入方法。
[source,java]
----
private List<SuperHero> superHeroes;

public void superHeroSelected(ItemClickEvent event) {
	SuperHero chosenSuperHero = this.superHeroes.get(event.getPosition());
	chosenSuperHero.summon();
}
----
如果我们只对事件本身感兴趣，也可以声明一个无参数的方法。
[source,java]
----
public void superHeroSelected() {
	System.out.println("SuperHeroes being summoned!");
}
----
AdapterViews绑定
~~~~~~~~~~~~~~~~
当我们需要绑定AdapterViews，RoboBinding需要你在presentation model上提供数据集属性。数据集属性类型可以是一个Array，List或者 ++org.robobinding.itempresentationmodel.TypedCursor++。
继续之前的例子，我们提供一个superHeroes List。除此只外，我们还要提供ItemPresentationModel(即数据项presentation model)，以便将每个数据项的显示视图绑定到ItemPresentationModel上。
RoboBinding里，我们通过在数据集属性上使用@ItemPresentationModel annotation做到。
[source,java]
----
@ItemPresentationModel(SuperHeroPresentationModel.class)
public List<SuperHero> getSuperHeroes() {
	return superHeroes;
}
----
每个数据项presentation model需要实现org.robobinding.itempresentationmodel.ItemPresentationModel接口，并在接口上声明数据项参数化类型。
[source,java]
----
public class SuperHeroPresentationModel 
			implements ItemPresentationModel<SuperHero> {
	
	private SuperHero superHero;
	
	public void updateData(int index, SuperHero superHero) {
		this.superHero = superHero;
	}
}
----
数据项layout xml示例 - simple_super_hero_row.xml如下：
----
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:bind="http://robobinding.org/android"
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical" />
	  
	  <TextView android:layout_width="fill_parent"
	      android:layout_height="wrap_content"
	      bind:text="{superHeroName}" />
	      
	  <TextView android:layout_width="fill_parent"
	      android:layout_height="wrap_content"
	      bind:text="{superHeroCallSign}" />
	      
</LinearLayout>
----
在数据项layout xml里声明的两个绑定属性，我们在对应的数据项presentation model里加入相应属性。
[source,java]
----
public class SuperHeroPresentationModel 
			implements ItemPresentationModel<SuperHero> {
	
	private SuperHero superHero;
	
	public String getSuperHeroName() {
	    return superHero.getName();
	}
	
	public String getSuperHeroCallSign() {
	    return superHero.getCallSign();
	}
	
	public void updateData(int index, SuperHero superHero) {
		this.superHero = superHero;
	}
}
----
最后我们在Activity layout xml里的ListView声明绑定信息。
[source,xml]
----
<ListView android:layout_width="fill_parent"
	  android:layout_height="fill_parent"
	  bind:onItemClick="superHeroSelected"
	  bind:source="{superHeroes}"
	  bind:itemLayout="@layout/simple_super_hero_row" />
----

羽量级关系数据与对象cursor映射
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
AdapterViews绑定中，我们提到数据集属性类型的一种为++org.robobinding.itempresentationmodel.TypedCursor++。
由于应用中我们通常都习惯于操作对象并尽量隔离关系数据操作的那部分代码，RoboBinding加入了羽量级对象化的Cursor - TypedCursor。
通过org.robobinding.itempresentationmodel.RowMapper<T>来将一行的关系数据映射为一个对象实例。接着以上AdapterViews的例子，我们将数据集属性类型改为TypedCursor<SuperHero>。
[source,java]
----
@ItemPresentationModel(SuperHeroPresentationModel.class)
public TypedCursor<SuperHero> getSuperHeroes() {
	allSuperHeroesQuery = new GetAllQuery<SuperHero>(SuperHero.TABLE_NAME, new SuperHeroRowMapper());
	return allSuperHeroesQuery.execute(db);
}
----
GetAllQuery实现如下：
[source,java]
----
public class GetAllQuery<T>
{
	private String tableName;
	private final RowMapper<T> rowMapper;

	public GetAllQuery(String tableName, RowMapper<T> rowMapper)
	{
	    this.tableName = tableName;
	    this.rowMapper = rowMapper;
	}

	public TypedCursor<T> execute(SQLiteDatabase db)
	{
		Cursor cursor = db.query(
				tableName,
				...,
				BaseColumns._ID+" ASC");
		return new org.robobinding.itempresentationmodel.TypedCursorAdapter<T>(cursor, rowMapper);
	}
}
----
SuperHeroRowMapper实现如下：
[source,java]
----
public class SuperHeroRowMapper implements org.robobinding.itempresentationmodel.RowMapper<SuperHero> {

    @Override
    public SuperHero mapRow(Cursor cursor) {
	String name = cursor.getString(cursor.getColumnIndex(SuperHeroTable.NAME));
	String callSign = cursor.getString(cursor.getColumnIndex(SuperHeroTable.CALL_SIGN));
	return new SuperHero(name, callSign);
    }

}
----
https://github.com/weicheng113/robobinding-gallery[RoboBinding Widget Gallery]下包含了一个简单的TypedCursor例子 - org.robobinding.gallery.model.typedcursor。

Album唱片集例子项目学习
-----------------------
项目中所带的Album唱片集例子是将Martin Fowler的原始版本翻译成基于RoboBinding的Android版本(Martin Fowler基于.Net的 http://martinfowler.com/eaaDev/PresentationModel.html[原始版本] )。
可以从 https://github.com/RoboBinding/RoboBinding[RoboBinding链接] 下找到robobinding-sample项目。

将项目导入Eclipse。文件->导入->Android->已存在的Android代码到工作区->浏览选择robobinding-sample文件夹，导入即可。

.Album唱片集例子原型
image::album_sample_prototype.png[]
以上是Album唱片集例子原型图。项目遵循RoboBinding应用的标准结构，即一个Activity由Activity主文件，Layout与PresentationModel Java文件组成。
项目源代码中包含以下几个包：org.robobinding.albumsample.activity包含所有Activity的主Java文件，org.robobinding.albumsample.presentationmodel包含所有PresentationModel Java文件，
org.robobinding.albumsample.model仅包含一个Album实体实现文件，org.robobinding.albumsample.store包含一个基于内存Album实体存储实现AlbumStore。接下来列出上述五张图所对应的实现文件。

图[Home Activity]由org.robobinding.albumsample.activity.HomeActivity，home_activity.xml与org.robobinding.albumsample.presentationmodel.HomePresentationModel组成。

图[View Albums Activity]由org.robobinding.albumsample.activity.ViewAlbumsActivity，view_albums_activity.xml与org.robobinding.albumsample.presentationmodel.ViewAlbumsPresentationModel组成;
其唱片集每行的唱片信息由org.robobinding.albumsample.presentationmodel.AlbumItemPresentationModel与album_row.xml组成；以及一个当唱片集为空时Layout显示文件albums_empty_view.xml。

图[Create Album Activity]与图[Edit Album Activity]由相同的org.robobinding.albumsample.activity.CreateEditAlbumActivity，create_edit_album_activity.xml与org.robobinding.albumsample.presentationmodel.CreateEditAlbumPresentationModel组成。

图[View Album Activity]由org.robobinding.albumsample.activity.ViewAlbumActivity，view_album_activity.xml与org.robobinding.albumsample.presentationmodel.ViewAlbumPresentationModel组成；
其删除对话框由org.robobinding.albumsample.activity.DeleteAlbumDialog，delete_album_dialog.xml与DeleteAlbumDialogPresentationModel组成。

以下以[View Albums Activity]为例，对源代码做简单介绍。Activity主Java文件ViewAlbumsActivity只做了一件事，就是把Layout文件view_albums_activity.xml与ViewAlbumsPresentationModel关联起来。
view_albums_activity.xml里包含了三个子视图按顺序为TextView, ListView与Button。TextView没有包含任何绑定信息。
ListView的++bind:source="\{albums\}"++绑定到ViewAlbumsPresentationModel.albums数据集属性。
++bind:onItemClick="viewAlbum"++绑定到ViewAlbumsPresentationModel.viewAlbum(ItemClickEvent)方法，单击某个唱片项时，该事件方法将被调用。
++bind:emptyViewLayout="@layout/albums_empty_view"++设置了当唱片集为空时的显示内容Layout。
++bind:itemLayout="@layout/album_row"++设置了唱片项的行显示Layout，结合在ViewAlbumsPresentationModel.albums上给出的数据项PresentationModel，即++@ItemPresentationModel(AlbumItemPresentationModel.class)++，
来显示每一个唱片行。在album_row.xml里包含了两个简单的TextView，其++bind:text="\{title\}"++与++bind:text="\{artist\}"++分别绑定到AlbumItemPresentationModel.title/artist属性。
在view_albums_activity.xml里的最后一个Button视图，++bind:onClick="createAlbum"++绑定到ViewAlbumsPresentationModel.createAlbum()方法。


创建自己的属性绑定实现
----------------------
自定义组件或第三方组件
~~~~~~~~~~~~~~~~~~~~~~
通过为自定义组件，第三方组件或未实现绑定的Android widget提供属性绑定实现，使它们更易于使用。在RoboBinding中，属性绑定实现方法是一致的。
当我们创建自己的属性绑定实现时，可以参考RoboBinding下的任何一个Android widget的属性绑定实现，如++org.robobinding.viewattribute.imageview++包与包下的++ImageViewAttributeMapper++类。

.自定义 Title Description Bar
image::custom_component.png[]

我们以上图的自定义组件TitleDescriptionBar为例。该组件包含了标题与描述两个部分。在输入新的标题与描述后，点击'Apply'，自定义组件的内容就更新为新的内容。
可以从https://github.com/weicheng113/robobinding-gallery[RoboBinding Widget Gallery]找到完整的代码。

以下是TitleDescriptionBar自定义组件的实现代码主要部分(如何实现自定义组件，请参考http://developer.android.com/guide/topics/ui/custom-components.html[Android文档]):
[source,java]
----
public class TitleDescriptionBar extends LinearLayout {
    private TextView title;
    private TextView description;

    public TitleDescriptionBar(Context context, AttributeSet attrs) {
		this(context, attrs, R.layout.title_description_bar);
    }

    protected TitleDescriptionBar(Context context, AttributeSet attrs, int layoutId) {
		super(context, attrs);

		LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		inflater.inflate(layoutId, this);
		title = (TextView) findViewById(R.id.title);
		description = (TextView) findViewById(R.id.description);
		...
    }

    public void setTitle(CharSequence titleText) {
		title.setText(titleText);
    }

    public void setDescription(CharSequence descriptionText) {
		description.setText(descriptionText);
    }
}
----
其Layout ++title_description_bar.xml++内容如下：
[source,xml]
----
<merge xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:bind="http://robobinding.org/android">
    <TextView android:id="@+id/title"/>
    <TextView android:text=": "/>
  	<TextView android:id="@+id/description"/>
----


我们想使TitleDescriptonBar组件使用起来能像以下++示例一样简单++。
[source,xml]
----
<org.robobinding.gallery.model.customcomponent.TitleDescriptionBar
	    bind:title="{title}"
	    bind:description="{description}"/>
----

实现绑定属性
^^^^^^^^^^^^
TitleDescriptionBar有标题与描述两个绑定属性，对应的实现分别是TitleAttribute与DescriptionAttribute。最后绑定属性映射TitleDescriptionBarAttributeMapper将属性映射到相应的实现类。
[source,java]
----
public class TitleAttribute extends AbstractTextAttribute {
    @Override
    protected void updateText(CharSequence newText) {
        view.setTitle(newText);
    }
}

public class DescriptionAttribute extends AbstractTextAttribute {
    @Override
    protected void updateText(CharSequence newText) {
	view.setDescription(newText);
    }
}

public class TitleDescriptionBarAttributeMapper implements BindingAttributeMapper<TitleDescriptionBar> {
    @Override
    public void mapBindingAttributes(BindingAttributeMappings<TitleDescriptionBar> mappings) {
        mappings.mapPropertyAttribute(TitleAttribute.class, "title");
        mappings.mapPropertyAttribute(DescriptionAttribute.class, "description");
    }
}
----
注册绑定属性映射类
^^^^^^^^^^^^^^^^^^
通过org.robobinding.binder.BinderFactoryBuilder注册绑定属性映射类。
[source,java]
----
BinderFactory binderFactory = new BinderFactoryBuilder()
        	.mapView(TitleDescriptionBar.class, new TitleDescriptionBarAttributeMapper())
        	.build();
ActivityBinder activityBinder = binderFactory.createActivityBinder(this, true);
activityBinder.inflateAndBind(R.layout.custom_component_activity, presentationModel);
----
这样我们很容易的就完成了属性绑定实现。我们以同样的方式可以为任何第三方组件或未实现绑定的Android widget提供属性绑定实现。

覆盖已有的属性绑定实现
~~~~~~~~~~~~~~~~~~~~~~
当RoboBinding框架已有的绑定属性不满足需求或没有相应的属性绑定实现时，我们有两种选择。第一种是修改框架代码，增加缺少的绑定属性(希望大家都参与贡献更多的绑定属性实现)。
第二种是不更改框架，实现相应的绑定属性与绑定属性映射类，然后注册覆盖已有的框架所提供的默认实现。
以第二种方式为例，我们来覆盖框架已有的http://developer.android.com/reference/android/widget/ImageView.html[ImageView]属性绑定实现++org.robobinding.viewattribute.imageview++。

实现新的绑定属性与映射类
^^^^^^^^^^^^^^^^^^^^^^^^
[source,java]
----
public class MyImageViewAttributeMapper implements BindingAttributeMapper<ImageView> {
    @Override
    public void mapBindingAttributes(BindingAttributeMappings<ImageView> mappings) {
	mappings.mapPropertyAttribute(MyImageSourceAttribute.class, "src");
    }

}

public class MyImageSourceAttribute extends org.robobinding.viewattribute.imageview.ImageSourceAttribute {
    @Override
    protected AbstractPropertyViewAttribute<ImageView, ?> createPropertyViewAttribute(Class<?> propertyType) {
		if (String.class.isAssignableFrom(propertyType)) {
			return new UrlImageSourceAttribute();
		} else {
			return super.createPropertyViewAttribute(propertyType);
		}
    }

    static class UrlImageSourceAttribute extends AbstractReadOnlyPropertyViewAttribute<ImageView, String> {
		@Override
		protected void valueModelUpdated(String url) {
			Bitmap image = loadBitmapFromUrl(url);//load image from given url.
			view.setImageBitmap(image);
		}
	}
}
----
注册覆盖框架已有的实现
^^^^^^^^^^^^^^^^^^^^^^
[source,java]
----
BinderFactory binderFactory = new BinderFactoryBuilder()
        	.mapView(ImageView.class, new MyImageViewAttributeMapper())
        	.build();
----


Layout文件Robobinding语法校验器插件
-----------------------------------
更新中。。。  请参考link:old_validator_plugin.html[旧文档]

其它资源
--------
*2012年一月* Robert Taylor 写了一些入门的文章在 http://roberttaylor426.blogspot.com/2011/11/hello-robobinding-part-1.html[这里] 和 http://roberttaylor426.blogspot.com/2012/01/hello-robobinding-part-2.html[这里]。

*2012年二月* 在London SkillsMatter，Robert Taylor作的RoboBinding介绍视频可以在 http://skillsmatter.com/podcast/os-mobile-server/core-dev-talk-robobinding[这里]找到。

*RoboBinding Widget Gallery* Cheng Wei 建立了https://github.com/weicheng113/robobinding-gallery[RoboBinding Widget Gallery]项目来展示所支持绑定属性的用法。
